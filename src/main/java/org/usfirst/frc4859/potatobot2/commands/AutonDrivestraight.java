// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4859.potatobot2.commands;

import com.ctre.phoenix.sensors.PigeonIMU;
import com.ctre.phoenix.sensors.PigeonIMU.PigeonState;

import org.usfirst.frc4859.potatobot2.Robot;
import org.usfirst.frc4859.potatobot2.RobotMap;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class AutonDrivestraight extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    private double time;
    private double speed; 
    private double currentAngle;
    double kPgain = 0.04; /* percent throttle per degree of error */
    double kDgain = 0.0004; /* percent throttle per angular velocity dps */
    double kMaxCorrectionRatio = 0.30; /* cap corrective turning throttle to 30 percent of forward throttle */

    public AutonDrivestraight(double inputSpeed, double _targetAngle) {
             speed = inputSpeed;
            // time = inputTime;
            
    //     PigeonIMU _pidgey = RobotMap.drivetrainPigeonIMU;
    //     //	robotDrive.tankDrive(speed, speed);
    //         PigeonIMU.GeneralStatus genStatus = new PigeonIMU.GeneralStatus();
    //         PigeonIMU.FusionStatus fusionStatus = new PigeonIMU.FusionStatus();
    //             double [] xyz_dps = new double [3];
    //     /* grab some input data from Pigeon and gamepad*/
    //          _pidgey.getGeneralStatus(genStatus);
    //         _pidgey.getRawGyro(xyz_dps);
    //             double currentAngle = _pidgey.getFusedHeading(fusionStatus);
    //             boolean angleIsGood = (_pidgey.getState() == PigeonState.Ready) ? true : false;
    //             double currentAngularRate = xyz_dps[2];
    //         RobotMap.drivetrainLeftMotor.set(-speed);
    //         RobotMap.drivetrainRightMotor.set(speed);
    //         SmartDashboard.putNumber("Pigdegy Yaw", currentAngle);
    //       //  * replace with favorite close loop strategy or leverage future Talon <=> Pigeon features. */
    //         double turnThrottle = (_targetAngle - currentAngle) * kPgain - (currentAngularRate) * kDgain;
    //         /* the max correction is the forward throttle times a scalar,
    //          * This can be done a number of ways but basically only apply small turning correction when we are moving slow
    //          * and larger correction the faster we move.  Otherwise you may need stiffer pgain at higher velocities. */
    //         double maxThrot = MaxCorrection(speed, kMaxCorrectionRatio);
    //         turnThrottle = Cap(turnThrottle, maxThrot);
    
    // // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    //     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    //     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
    //     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // requires(Robot.drivetrain);
    
     }
        	/**
        * As a simple trick, lets take the spare talon and use the web-based
        * config to easily change the gains we use for the Pigeon servo.
        * The talon isn't being used for closed-loop, just use it as a convenient
        * storage for gains.
        */
        void UpdatGains() {
            kPgain = RobotMap.drivetrainPigeonMotor.get();
            kDgain = RobotMap.drivetrainPigeonMotor.get();
            kMaxCorrectionRatio = RobotMap.drivetrainPigeonMotor.get();
    
}
  /**
         * Given the robot forward throttle and ratio, return the max
         * corrective turning throttle to adjust for heading.  This is
         * a simple method of avoiding using different gains for
         * low speed, high speed, and no-speed (zero turns).
         */
        double MaxCorrection(double forwardThrot, double scalor) {
            /* make it positive */
            if(forwardThrot < 0) {forwardThrot = -forwardThrot;}
            /* max correction is the current forward throttle scaled down */
            forwardThrot *= scalor;
            /* ensure caller is allowed at least 10% throttle,
            * regardless of forward throttle */
            if(forwardThrot < 0.10)
                return 0.10;
            return forwardThrot;
    }
            /** @param value to cap.
             * @param peak positive double representing the maximum (peak) value.
             * @return a capped value.
             */
            double Cap(double value, double peak) {
                if (value < -peak)
                    return -peak;
                if (value > +peak)
                    return +peak;
                return value;
            }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        setTimeout(time); 
        System.out.println("In auton init");
        SmartDashboard.putString("Auton", "initialize");
      //  PigeonIMU _pidgey = RobotMap.drivetrainPigeonIMU;
     //   PigeonIMU.GeneralStatus genStatus = new PigeonIMU.GeneralStatus();
    //    PigeonIMU.FusionStatus fusionStatus = new PigeonIMU.FusionStatus();
    //        double [] xyz_dps = new double [3];
      //  _pidgey.getGeneralStatus(genStatus);
     //   _pidgey.getRawGyro(xyz_dps);
     //       currentAngle = _pidgey.getFusedHeading(fusionStatus);
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        System.out.println("in execute");
        Robot.drivetrain.driveStraight(speed, currentAngle);
        SmartDashboard.putString("Auton", "execute");
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return isTimedOut();
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.drivetrain.driveStraight(0, currentAngle);
        SmartDashboard.putString("Auton", "End");
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        Robot.drivetrain.driveStraight(0, currentAngle);
    }
}
