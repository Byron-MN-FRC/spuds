// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4859.potatobot2.subsystems;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.sensors.PigeonIMU;
import com.ctre.phoenix.sensors.PigeonIMU.PigeonState;

import org.usfirst.frc4859.potatobot2.RobotMap;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class drivetrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX leftMotor = RobotMap.drivetrainLeftMotor;
    private final WPI_TalonSRX rightMotor = RobotMap.drivetrainRightMotor;
   //private final RobotDrive robotDrive = RobotMap.drivetrainRobotDrive;
    double kPgain = 0.04; /* percent throttle per degree of error */
    double kDgain = 0.0004; /* percent throttle per angular velocity dps */
    double kMaxCorrectionRatio = 0.30; /* cap corrective turning throttle to 30 percent of forward throttle */

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void arcadedrive(Joystick stick) {
    		//robotDrive.arcadeDrive(stick);
    }
    public void driveStraight(double speed, double _targetAngle) {
        System.out.println("in drivestraight");
        PigeonIMU _pidgey = RobotMap.drivetrainPigeonIMU;
    //	robotDrive.tankDrive(speed, speed);
        PigeonIMU.GeneralStatus genStatus = new PigeonIMU.GeneralStatus();
        PigeonIMU.FusionStatus fusionStatus = new PigeonIMU.FusionStatus();
            double [] xyz_dps = new double [3];
    /* grab some input data from Pigeon and gamepad*/
         _pidgey.getGeneralStatus(genStatus);
        _pidgey.getRawGyro(xyz_dps);
            double currentAngle = _pidgey.getFusedHeading(fusionStatus);
            boolean angleIsGood = (_pidgey.getState() == PigeonState.Ready) ? true : false;
            double currentAngularRate = xyz_dps[2];
        leftMotor.set(-speed);
        rightMotor.set(speed);
        SmartDashboard.putNumber("Pigdegy Yaw", currentAngle);
      //  * replace with favorite close loop strategy or leverage future Talon <=> Pigeon features. */
        double turnThrottle = (_targetAngle - currentAngle) * kPgain - (currentAngularRate) * kDgain;
        /* the max correction is the forward throttle times a scalar,
         * This can be done a number of ways but basically only apply small turning correction when we are moving slow
         * and larger correction the faster we move.  Otherwise you may need stiffer pgain at higher velocities. */
        double maxThrot = MaxCorrection(speed, kMaxCorrectionRatio);
        turnThrottle = Cap(turnThrottle, maxThrot);

        }	/**
        * As a simple trick, lets take the spare talon and use the web-based
        * config to easily change the gains we use for the Pigeon servo.
        * The talon isn't being used for closed-loop, just use it as a convenient
        * storage for gains.
        */
        void UpdatGains() {
            kPgain = RobotMap.drivetrainPigeonMotor.get();
            kDgain = RobotMap.drivetrainPigeonMotor.get();
            kMaxCorrectionRatio = RobotMap.drivetrainPigeonMotor.get();
            
        }
         /**
         * Given the robot forward throttle and ratio, return the max
         * corrective turning throttle to adjust for heading.  This is
         * a simple method of avoiding using different gains for
         * low speed, high speed, and no-speed (zero turns).
         */
        double MaxCorrection(double forwardThrot, double scalor) {
            /* make it positive */
            if(forwardThrot < 0) {forwardThrot = -forwardThrot;}
            /* max correction is the current forward throttle scaled down */
            forwardThrot *= scalor;
            /* ensure caller is allowed at least 10% throttle,
            * regardless of forward throttle */
            if(forwardThrot < 0.10)
                return 0.10;
            return forwardThrot;
    }
            /** @param value to cap.
             * @param peak positive double representing the maximum (peak) value.
             * @return a capped value.
             */
            double Cap(double value, double peak) {
                if (value < -peak)
                    return -peak;
                if (value > +peak)
                    return +peak;
                return value;
            }
     }

